import numpy as np

from adapt_utils.case_studies.tohoku.options.options import TohokuOptions


__all__ = ["TohokuOkadaBasisOptions"]


class TohokuOkadaBasisOptions(TohokuOptions):
    """
    Initialise the free surface with an initial condition generated using Okada functions.

    Note that, unlike in the basis comprised of an array of piecewise constant or radial basis
    functions, the relationship between the control parameters and the initial surface is nonlinear.
    In addition, zero is not a feasible initial guess for the Okada parameters, meaning some physical
    intuition is required in order to set up the problem.

    Control parameters comprise of a dictionary of lists containing the following parameters. The
    list index corresponds to the subfault within the main fault. By default, a 19 x 10 grid of
    25km x 20km subfaults is considered, using the work of [Shao et al. 2011].

      * 'depth'     - depth of the centroid of the subfault plane [m].
      * 'length'    - length of the subfault plane [m].
      * 'width'     - width of the subfault plane [m].
      * 'slip'      - average displacement [m].
      * 'strike'    - angle from north of subfault [radians].
      * 'dip'       - angle from horizontal [radians].
      * 'rake'      - slip of one subfault block compared to another [radians].
      * 'latitude'  - latitude of the centroid of the subfault [degrees].
      * 'longitude' - longitude of the centroid of the subfault [degrees].

    [Shao et al. 2011] G. Shao, X. Li, C. Ji & T. Maeda, "Focal mechanism and slip history of the
                       2011 Mw 9.1 off the Pacific coast of Tohoku Earthquake, constrained with
                       teleseismic body and surface waves", Earth, Planets and Space 63.7 (2011),
                       p.559--564.
    """

    # --- Initialisation

    def __init__(self, **kwargs):
        """
        :kwarg control_parameters: a dictionary of values to use for the basis function coefficients.
        :kwarg centre_x: x-coordinate of centre of source region in UTM coordinates.
        :kwarg centre_y: y-coordinate of centre of source region in UTM coordinates.
        :kwarg nx: number of sub-faults along strike direction.
        :kwarg ny: number of sub-faults perpendicular to the strike direction.
        :kwarg okada_grid_resolution: integer N giving rise to an N x N grid upon which to evaluate
            the Okada functions and hence the resulting fault surface.
        :kwarg okada_grid_length_lon: extent of the Okada grid in the longitudinal direction.
        :kwarg okada_grid_length_lat: extent of the Okada grid in the latitudinal direction.
        :kwarg okada_grid_lon_min: minimum longitude in the Okada grid.
        :kwarg okada_grid_lat_min: minimum latitude in the Okada grid.
        """
        super(TohokuOkadaBasisOptions, self).__init__(**kwargs)
        self.control_parameters = kwargs.get('control_parameters')
        self.coordinate_specification = kwargs.get('coordinate_specification', 'centroid')
        self.N = kwargs.get('okada_grid_resolution', 101)
        self.lx = kwargs.get('okada_grid_length_lon', 10)
        self.ly = kwargs.get('okada_grid_length_lat', 10)
        self.xmin = kwargs.get('okada_grid_lon_min', 138)
        self.ymin = kwargs.get('okada_grid_lat_min', 32)
        self.subfaults = []
        self.get_subfaults()
        self.all_controls = (
            'latitude', 'longitude', 'depth',
            'slip', 'rake', 'strike', 'dip',
            'length', 'width',
        )

        # Numbers of sub-faults in each direction
        self.nx = kwargs.get('nx', 19)
        self.ny = kwargs.get('ny', 10)
        assert self.nx*self.ny == len(self.subfaults)

        # Active controls for automatic differentation
        self.active_controls = ('slip', 'rake', 'strike', 'dip')

    def download_okada_parameters(self):
        """
        Download the Okada parameters generated by [Shao et al. 2011] from the webpage
          `http://ji.faculty.geol.ucsb.edu/big_earthquakes/2011/03/0311_v3/result_c/static_out`.

        A 19 x 10 array of Okada functions was assumed, each of which with a length of 25km and a
        width of 20km. Note that the webpage also provides initial times, rise times and end times
        for each subfault, although we do not use these here.
        """
        # TODO: Use geoclaw's inbuild functionality for reading from UCSB format
        import os
        import urllib.request

        # Read data from file or downloaded it
        fname = os.path.join(self.resource_dir, 'surf', 'okada_parameters.txt')
        url = "http://ji.faculty.geol.ucsb.edu/big_earthquakes/2011/03/0311_v3/result_c/static_out"
        if os.path.exists(fname):
            data = open(fname, 'r').readlines()
        else:
            with urllib.request.urlopen(url) as fp:
                data_bytes = fp.read()                # read webpage as bytes
                data_str = data_bytes.decode("utf8")  # convert to a string
                with open(fname, 'w+') as f:
                    f.write(data_str)                 # save for future use
                data = data_str.split('\n')

        # Create a dictionary to contain the parameters
        self.all_controls = ('latitude', 'longitude', 'depth', 'slip', 'rake', 'strike', 'dip')
        self.control_parameters = {}
        for control in self.all_controls:
            self.control_parameters[control] = []
        self.control_parameters['length'] = []
        self.control_parameters['width'] = []

        # Extract the data and enter it into the dictionary
        for i, line in enumerate(data):
            if i < 12:
                continue
            for word, control in zip(line.split(), self.all_controls):
                val = float(word)
                if control == 'slip':
                    val /= 100  # convert from cm to m
                if control == 'depth':
                    val *= 1000  # convert from km to m
                self.control_parameters[control].append(val)
            if line not in ('', '\n'):
                self.control_parameters['length'].append(25.0e+03)
                self.control_parameters['width'].append(20.0e+03)
        self.all_controls += ('length', 'width', )

    def get_subfaults(self, check_validity=False):
        """
        Create GeoCLAW :class:`SubFault` objects from provided subfault parameters, as well as a
        :class`Fault` object.

        If control parameters were not provided then data are downloaded according to the
        `download_okada_parameters` method.
        """
        from adapt_utils.unsteady.swe.tsunami.dtopotools import Fault, SubFault

        # If no Okada parameters have been provided then download them from a default webpage
        if self.control_parameters is None or self.control_parameters == {}:
            self.download_okada_parameters()

        # Check consistency of the inputs
        num_subfaults = len(self.control_parameters['latitude'])
        msg = "Mismatching '{:s}' data: {:d} controls vs. {:d} subfaults"
        for var in self.control_parameters:
            num_ctrls = len(self.control_parameters[var])
            assert num_ctrls == num_subfaults, msg.format(var, num_ctrls, num_subfaults)

        # Check validity of the inputs
        if check_validity:
            for i in range(num_subfaults):
                for var in ('depth', 'slip'):
                    value = self.control_parameters[var][i]
                    assert value > 0, "{:s} is not allowed to be negative".format(var.capitalize())
                lon = self.control_parameters['longitude'][i]
                lat = self.control_parameters['latitude'][i]
                self.check_in_domain([lon, lat])

        # Create subfaults
        for i in range(num_subfaults):
            subfault = SubFault()
            subfault.coordinate_specification = self.coordinate_specification
            self.subfaults.append(subfault)

        # Create a lon-lat grid upon which to represent the source
        x = np.linspace(self.xmin, self.xmin + self.lx, self.N)
        y = np.linspace(self.ymin, self.ymin + self.ly, self.N)

        # Create fault
        self.fault = Fault(x, y, subfaults=self.subfaults)

    def set_initial_condition(self, prob, annotate_source=False, **kwargs):
        """
        Set initial condition using the Okada parametrisation [Okada 85].

        Uses code from GeoCLAW found in `geoclaw/src/python/geoclaw/dtopotools.py`.

        [Okada 85] Yoshimitsu Okada, "Surface deformation due to shear and tensile faults in a
                   half-space", Bulletin of the Seismological Society of America, Vol. 75, No. 4,
                   pp.1135--1154, (1985).

        :arg prob: :class:`AdaptiveTsunamiProblem` solver object.
        :kwarg annotate_source: toggle annotation of the rupture process using pyadolc.
        :kwarg tag: non-negative integer label for tape.
        """
        from scipy.interpolate import interp2d
        import firedrake

        # Create fault topography
        self.create_topography(annotate=annotate_source, **kwargs)

        # Interpolate it using SciPy
        surf_interp = interp2d(self.fault.dtopo.x, self.fault.dtopo.y, self.fault.dtopo.dZ)

        # Evaluate the interpolant at the mesh vertices
        surf = firedrake.Function(prob.P1[0])
        if not hasattr(self, 'lonlat_mesh'):
            self.get_lonlat_mesh()
        for i, xy in enumerate(self.lonlat_mesh.coordinates.dat.data):
            surf.dat.data[i] = surf_interp(*xy)

        # Interpolate into the elevation space
        u, eta = prob.fwd_solutions[0].split()
        eta.interpolate(surf)

        # Subtract initial surface from the bathymetry field
        self.subtract_surface_from_bathymetry(prob, surf=surf)
        return surf

    def create_topography(self, annotate=False, interpolate=False, **kwargs):
        """
        Compute the topography dislocation due to the earthquake using the Okada model. This
        implementation makes use of the :class:`Fault` and :class:`SubFault` objects from GeoClaw.

        If annotation is turned on, the rupture process is annotated using the Python wrapper
        `pyadolc` to the C++ operator overloading automatic differentation tool ADOL-C.

        :kwarg annotate: toggle annotation using pyadolc.
        :kwarg interpolate: see the :attr:`interpolate` method.
        :kwarg tag: label for tape.
        """
        msg = "Fault corresponds to an earthquake with moment magnitude {:4.1e}"
        if annotate:
            if interpolate:
                self._create_topography_active_interpolate(**kwargs)
            else:
                self._create_topography_active(**kwargs)
            self.print_debug(msg.format(self.fault.Mw().val))
        else:
            self._create_topography_passive()
            self.print_debug(msg.format(self.fault.Mw()))

    def _create_topography_passive(self):
        msg = "Subfault {:d}: shear modulus {:4.1e} Pa, seismic moment is {:4.1e}"
        for i, subfault in enumerate(self.subfaults):
            for control in self.all_controls:
                subfault.__setattr__(control, self.control_parameters[control][i])
            self.print_debug(msg.format(i, subfault.mu, subfault.Mo()))
        self.fault.create_dtopography(verbose=self.debug, active=False)

    # --- Automatic differentiation

    def _create_topography_active(self, tag=0, separate_faults=True):
        import adolc

        # Sanitise kwargs
        assert isinstance(tag, int)
        assert tag >= 0
        for control in self.active_controls:
            assert control in self.all_controls

        # Initialise tape
        adolc.trace_on(tag)

        # Read parameters and mark active variables as independent
        msg = "Subfault {:d}: shear modulus {:4.1e} Pa, seismic moment is {:4.1e}"
        for i, subfault in enumerate(self.subfaults):
            for control in self.all_controls:
                if control in self.active_controls:
                    subfault.__setattr__(control, adolc.adouble(self.control_parameters[control][i]))
                    adolc.independent(subfault.__getattribute__(control))
                else:
                    subfault.__setattr__(control, self.control_parameters[control][i])
            self.print_debug(msg.format(i, subfault.mu, subfault.Mo().val))

        # Create the topography, thereby calling Okada
        self.print_debug("SETUP: Creating topography using Okada model...")
        self.fault.create_dtopography(verbose=self.debug, active=True)
        self.print_debug("SETUP: Done!")

        # Mark output as dependent
        if separate_faults:
            for subfault in self.subfaults:
                adolc.dependent(subfault.dtopo.dZ)
        else:
            adolc.dependent(self.fault.dtopo.dZ_a)
        adolc.trace_off()

    def _create_topography_active_interpolate(self, tag=0, separate_faults=False):
        import adolc

        # Sanitise kwargs
        assert isinstance(tag, int)
        assert tag >= 0
        for control in self.active_controls:
            assert control in self.all_controls

        # Initialise tape
        adolc.trace_on(tag)

        # Read parameters and mark active variables as independent
        msg = "Subfault {:d}: shear modulus {:4.1e} Pa, seismic moment is {:4.1e}"
        for i, subfault in enumerate(self.subfaults):
            for control in self.all_controls:
                if control in self.active_controls:
                    subfault.__setattr__(control, adolc.adouble(self.control_parameters[control][i]))
                    adolc.independent(subfault.__getattribute__(control))
                else:
                    subfault.__setattr__(control, self.control_parameters[control][i])
            self.print_debug(msg.format(i, subfault.mu, subfault.Mo().val))

        # Create the topography, thereby calling Okada
        self.print_debug("SETUP: Creating topography using Okada model...")
        self.fault.create_dtopography(verbose=self.debug, active=True)
        self.print_debug("SETUP: Done!")

        # Compute quantity of interest
        self.J_subfaults = [0.0 for j in range(self.N)]
        data = self._data_to_interpolate
        for j in range(self.N):
            for i in range(self.N):
                self.J_subfaults[j] += (data[i, j] - self.fault.dtopo.dZ_a[i, j])**2
            self.J_subfaults[j] /= self.N**2
        self.J = sum(self.J_subfaults)

        # Mark dependence
        if separate_faults:
            for j in range(self.N):
                adolc.dependent(self.J_subfaults[j])
        else:
            adolc.dependent(self.J)
        adolc.trace_off()

    def get_input_vector(self):
        """
        Get a vector of the same length as the total number of controls and populate it with passive
        versions of each parameter. This provides a point at which we can compute derivative
        matrices.
        """
        controls = self.control_parameters
        num_subfaults = len(self.subfaults)
        X = [controls[control][i] for i in range(num_subfaults) for control in self.active_controls]
        self.input_vector = np.array(X)
        return self.input_vector

    def get_seed_matrices(self):
        """
        Whilst the Okada function on each subfault is a nonlinear function of the associated
        controls, the total dislocation is just the sum over all subfaults. As such, the
        derivatives with respect to each parameter type (e.g. slip) may be computed simultaneously.
        All we need to do is choose an appropriate 'seed matrix' to propagate through the forward
        mode of AD.

        In the default case we have four active controls and hence there are four seed matrices.
        """
        if not hasattr(self, 'input_vector'):
            self.get_input_vector()
        n = len(self.active_controls)
        S = [[1 if i % n == j else 0 for j in range(n)] for i in range(len(self.input_vector))]
        self.seed_matrices = np.array(S)
        return self.seed_matrices

    # --- Interpolation between Okada grid and computational mesh

    def get_interpolation_operators(self):
        """
        Establish the mapping between Okada grid
        """
        import firedrake
        from firedrake.projection import SupermeshProjector

        # Create a Firedrake mesh associated with the (uniform) Okada grid.
        self.okada_mesh = firedrake.SquareMesh(self.N-1, self.N-1, self.lx, self.ly)
        self.okada_mesh.coordinates.dat.data[:] += [self.xmin, self.ymin]

        # Create function spaces associated with both the Okada and longitude-latitude meshes
        self.P1_okada = firedrake.FunctionSpace(self.okada_mesh, "CG", 1)
        if not hasattr(self, 'lonlat_mesh'):
            self.get_lonlat_mesh()
        self.P1_lonlat = firedrake.FunctionSpace(self.lonlat_mesh, "CG", 1)

        # Establish an index mapping between the logical x- and y- directions and the vertex
        # ordering used by Firedrake's utility mesh, :class:`SquareMesh`.
        self.print_debug("SETUP: Establishing index mapping for Okada mesh...")
        self._x_locations, self._y_locations = [], []
        for i, coord in enumerate(self.okada_mesh.coordinates.dat.data):
            self._x_locations.append(int(np.round((coord[0] - self.xmin)*(self.N-1)/self.lx)))
            self._y_locations.append(int(np.round((coord[1] - self.ymin)*(self.N-1)/self.ly)))
        self.print_debug("SETUP: Done!")

        # Create source and target images and a libsupermesh projector between them
        self.print_debug("SETUP: Establishing supermesh projector between Okada and lonlat meshes...")
        self.source_okada = firedrake.Function(self.P1_okada, name="Interp. source on Okada mesh")
        self.target_lonlat = firedrake.Function(self.P1_lonlat, name="Interp. target on lonlat mesh")
        self._okada2lonlat = SupermeshProjector(self.source_okada, self.target_lonlat)
        self.print_debug("SETUP: Done!")

        # Target image on UTM mesh
        P1 = firedrake.FunctionSpace(self.default_mesh, "CG", 1)
        self.target_utm = firedrake.Function(P1, name="Interpolation target on UTM mesh")

    def _field_from_array(self, arr):
        """
        Insert an array `arr` from the Okada model into the source field defined on the Firedrake
        Okada mesh.
        """
        if not hasattr(self, 'source_okada'):
            self.get_interpolation_operators()
        assert arr.shape == (self.N, self.N)
        for k in range(self.N*self.N):
            self.source_okada.dat.data[k] = arr[self._y_locations[k], self._x_locations[k]]

    def interpolate_okada_array(self, arr):
        """
        Given an array `arr` obtained from the Okada model, interpolate it onto the Firedrake mesh
        in UTM coordinates, i.e. :attr:`self.default_mesh`.

        The return value may also be found as :attr:`target_utm`. Along the way, we also obtain the
        representation in longitude-latitude space, which may be found as :attr:`target_lonlat`. The
        source image on the Okada mesh may be found as :attr:`source_okada`.
        """
        if not hasattr(self, 'source_okada'):
            self.get_interpolation_operators()

        # Copy data onto Firedrake Okada mesh
        self._field_from_array(arr)

        # Project from Okada mesh to longitude-latitude mesh
        self._okada2lonlat.project()

        # Transfer from longitude-latitude to UTM mesh
        self.target_utm.dat.data[:] = self.target_lonlat.dat.data
        return self.target_utm

    # --- Regularisation

    def get_regularisation_term(self, prob):
        raise NotImplementedError  # TODO

    # --- Projection and interpolation into Okada basis

    def project(self, prob, source):
        raise NotImplementedError("""
            Projection not implemented in Okada bases (and it probably isn't what you want anyway).
            Use interpolate instead.""")

    def interpolate(self, prob, source, tag=0):
        r"""
        Interpolate a source field into the radial basis using point evaluation.

        This involves solving an auxiliary optimisation problem! The objective functional is

      ..math::
            J(\mathbf m) = \tilde J(\mathbf m) \cdot \tilde J(\mathbf m),

        where :math:`m` is the control vector, :math:`\boldsymbol\phi` is the vector (radial) basis
        functions, :math:`f` is the source field we seek to represent and

      ..math::
            \tilde J(\mathbf m)_i = \frac1N\int_\Omega\sum_i(f^{okada}(\mathbf m)_i-f_i)\;\mathrm dx,

        where :math:`f^{okada}(\mathbf m)_i` is the result of the Okada model with control parameters
        :math:`\mathbf m`, evaluated at the centre of basis function :math:`i`. and :math:`N` is the
        number of radial basis functions.

        Solving this optimisation problem using a gradient-based approach means that we need to be
        able to differentiate the Okada model. We do this using the PyADOLC Python wrapper for the
        C++ operator overloading AD tool, ADOL-C.
        """
        # from adapt_utils.norms import vecnorm

        self._data_to_interpolate = source  # TODO: Probably needs discretising on Okada grid
        self.create_topography(annotate=True, interpolate=True, tag=tag)
        self.get_seed_matrices()
        raise NotImplementedError  # TODO: Copy over from notebook
